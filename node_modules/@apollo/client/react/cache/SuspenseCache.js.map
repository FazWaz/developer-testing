{"version":3,"file":"SuspenseCache.js","sourceRoot":"","sources":["../../../src/react/cache/SuspenseCache.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,IAAI,EAAE,MAAM,WAAW,CAAC;AAEjC,OAAO,EAAE,aAAa,EAAE,MAAM,iBAAiB,CAAC;AAChD,OAAO,EAAE,sBAAsB,EAAE,MAAM,kBAAkB,CAAC;AAiB1D;IAIE,uBAAY,OAAmD;QAAnD,wBAAA,EAAA,UAAgC,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC;QAHvD,cAAS,GAAG,IAAI,IAAI,CAAuC,aAAa,CAAC,CAAC;QAIhF,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC;IACzB,CAAC;IAED,mCAAW,GAAX,UACE,QAAkB,EAClB,gBAA8C;QAE9C,IAAM,GAAG,GAAG,IAAI,CAAC,SAAS,CAAC,WAAW,CAAC,QAAQ,CAAC,CAAC;QAEjD,IAAI,CAAC,GAAG,CAAC,OAAO,EAAE;YAChB,GAAG,CAAC,OAAO,GAAG,IAAI,sBAAsB,CAAC,gBAAgB,EAAE,EAAE;gBAC3D,GAAG,EAAE,QAAQ;gBACb,oBAAoB,EAAE,IAAI,CAAC,OAAO,CAAC,oBAAoB;gBACvD,SAAS,EAAE;oBACT,OAAO,GAAG,CAAC,OAAO,CAAC;gBACrB,CAAC;aACF,CAAC,CAAC;SACJ;QAED,OAAO,GAAG,CAAC,OAAwC,CAAC;IACtD,CAAC;IACH,oBAAC;AAAD,CAAC,AA1BD,IA0BC","sourcesContent":["import { Trie } from '@wry/trie';\nimport type { ObservableQuery } from '../../core';\nimport { canUseWeakMap } from '../../utilities';\nimport { InternalQueryReference } from './QueryReference';\nimport type { CacheKey } from './types';\n\ninterface SuspenseCacheOptions {\n  /**\n   * Specifies the amount of time, in milliseconds, the suspense cache will wait\n   * for a suspended component to read from the suspense cache before it\n   * automatically disposes of the query. This prevents memory leaks when a\n   * component unmounts before a suspended resource finishes loading. Increase\n   * the timeout if your queries take longer than than the specified time to\n   * prevent your queries from suspending over and over.\n   *\n   * Defaults to 30 seconds.\n   */\n  autoDisposeTimeoutMs?: number;\n}\n\nexport class SuspenseCache {\n  private queryRefs = new Trie<{ current?: InternalQueryReference }>(canUseWeakMap);\n  private options: SuspenseCacheOptions;\n\n  constructor(options: SuspenseCacheOptions = Object.create(null)) {\n    this.options = options;\n  }\n\n  getQueryRef<TData = any>(\n    cacheKey: CacheKey,\n    createObservable: () => ObservableQuery<TData>\n  ) {\n    const ref = this.queryRefs.lookupArray(cacheKey);\n\n    if (!ref.current) {\n      ref.current = new InternalQueryReference(createObservable(), {\n        key: cacheKey,\n        autoDisposeTimeoutMs: this.options.autoDisposeTimeoutMs,\n        onDispose: () => {\n          delete ref.current;\n        },\n      });\n    }\n\n    return ref.current as InternalQueryReference<TData>;\n  }\n}\n"]}