import { __assign } from "tslib";
import { NetworkStatus, isNetworkRequestSettled } from "../../core/index.js";
import { createFulfilledPromise, createRejectedPromise } from "../../utilities/index.js";
export var QUERY_REFERENCE_SYMBOL = Symbol();
var InternalQueryReference = (function () {
    function InternalQueryReference(observable, options) {
        var _this = this;
        var _a;
        this.listeners = new Set();
        this.initialized = false;
        this.refetching = false;
        this.listen = this.listen.bind(this);
        this.handleNext = this.handleNext.bind(this);
        this.handleError = this.handleError.bind(this);
        this.dispose = this.dispose.bind(this);
        this.observable = observable;
        this.result = observable.getCurrentResult(false);
        this.key = options.key;
        if (options.onDispose) {
            this.onDispose = options.onDispose;
        }
        if (isNetworkRequestSettled(this.result.networkStatus) ||
            (this.result.data &&
                (!this.result.partial || this.observable.options.returnPartialData))) {
            this.promise = createFulfilledPromise(this.result);
            this.initialized = true;
            this.refetching = false;
        }
        this.subscription = observable.subscribe({
            next: this.handleNext,
            error: this.handleError,
        });
        if (!this.promise) {
            this.promise = new Promise(function (resolve, reject) {
                _this.resolve = resolve;
                _this.reject = reject;
            });
        }
        this.autoDisposeTimeoutId = setTimeout(this.dispose, (_a = options.autoDisposeTimeoutMs) !== null && _a !== void 0 ? _a : 30000);
    }
    Object.defineProperty(InternalQueryReference.prototype, "watchQueryOptions", {
        get: function () {
            return this.observable.options;
        },
        enumerable: false,
        configurable: true
    });
    InternalQueryReference.prototype.listen = function (listener) {
        var _this = this;
        clearTimeout(this.autoDisposeTimeoutId);
        this.listeners.add(listener);
        return function () {
            _this.listeners.delete(listener);
        };
    };
    InternalQueryReference.prototype.refetch = function (variables) {
        this.refetching = true;
        var promise = this.observable.refetch(variables);
        this.promise = promise;
        return promise;
    };
    InternalQueryReference.prototype.fetchMore = function (options) {
        var promise = this.observable.fetchMore(options);
        this.promise = promise;
        return promise;
    };
    InternalQueryReference.prototype.reobserve = function (watchQueryOptions) {
        var promise = this.observable.reobserve(watchQueryOptions);
        this.promise = promise;
        return promise;
    };
    InternalQueryReference.prototype.dispose = function () {
        this.subscription.unsubscribe();
        this.onDispose();
    };
    InternalQueryReference.prototype.onDispose = function () {
    };
    InternalQueryReference.prototype.handleNext = function (result) {
        if (!this.initialized || this.refetching) {
            if (!isNetworkRequestSettled(result.networkStatus)) {
                return;
            }
            if (this.result.data && result.data === void 0) {
                result.data = this.result.data;
            }
            this.initialized = true;
            this.refetching = false;
            this.result = result;
            if (this.resolve) {
                this.resolve(result);
            }
            return;
        }
        if (result.data === this.result.data) {
            return;
        }
        this.result = result;
        this.promise = createFulfilledPromise(result);
        this.deliver(this.promise);
    };
    InternalQueryReference.prototype.handleError = function (error) {
        var result = __assign(__assign({}, this.result), { error: error, networkStatus: NetworkStatus.error });
        this.result = result;
        if (!this.initialized || this.refetching) {
            this.initialized = true;
            this.refetching = false;
            if (this.reject) {
                this.reject(error);
            }
            return;
        }
        this.result = result;
        this.promise = result.data
            ? createFulfilledPromise(result)
            : createRejectedPromise(result);
        this.deliver(this.promise);
    };
    InternalQueryReference.prototype.deliver = function (promise) {
        this.listeners.forEach(function (listener) { return listener(promise); });
    };
    return InternalQueryReference;
}());
export { InternalQueryReference };
//# sourceMappingURL=QueryReference.js.map