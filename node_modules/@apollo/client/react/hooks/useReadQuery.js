import { useState, useMemo, useEffect } from "react";
import invariant from "ts-invariant";
import { NetworkStatus } from "../../core/index.js";
import { QUERY_REFERENCE_SYMBOL } from "../cache/QueryReference.js";
import { __use } from "./internal/index.js";
import { toApolloError } from "./useSuspenseQuery.js";
export function useReadQuery(queryRef) {
    var _a = useState(0), forceUpdate = _a[1];
    var internalQueryRef = queryRef[QUERY_REFERENCE_SYMBOL];
    invariant(internalQueryRef.promiseCache, 50);
    var skipResult = useMemo(function () {
        var error = toApolloError(internalQueryRef.result);
        return {
            loading: false,
            data: internalQueryRef.result.data,
            networkStatus: error ? NetworkStatus.error : NetworkStatus.ready,
            error: error,
        };
    }, [internalQueryRef.result]);
    var promise = internalQueryRef.promiseCache.get(internalQueryRef.key);
    if (!promise) {
        promise = internalQueryRef.promise;
        internalQueryRef.promiseCache.set(internalQueryRef.key, promise);
    }
    useEffect(function () {
        return internalQueryRef.listen(function (promise) {
            internalQueryRef.promiseCache.set(internalQueryRef.key, promise);
            forceUpdate(function (prevState) { return prevState + 1; });
        });
    }, [queryRef]);
    var result = internalQueryRef.watchQueryOptions.fetchPolicy === 'standby'
        ? skipResult
        : __use(promise);
    return useMemo(function () {
        return {
            data: result.data,
            networkStatus: result.networkStatus,
            error: toApolloError(result),
        };
    }, [result]);
}
//# sourceMappingURL=useReadQuery.js.map